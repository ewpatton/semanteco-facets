//here we are binding the search to specific species
		if(request.getParam("species") != null && ((JSONArray) request.getParam("species")).length() > 1  ){// && request.getParam("species").length() > 0) {
		    request.getLogger().error("species length: " + ((JSONArray) request.getParam("species")).length());
		    request.getLogger().error("(got to else if where species > 1)");

			//note that this is going to be a json array of strings
			//you're "joining" on the scientific name, for now
			JSONArray speciesParams = (JSONArray)request.getParam("species");	
			final UnionComponent union = query.createUnion();
			final NamedGraphComponent graph2 = query.getNamedGraph("http://was.tw.rpi.edu/ebird-taxonomy");
			graph2.addGraphComponent(union);
			//GraphComponentCollection coll = union.getUnionComponent(0);
			GraphComponentCollection coll;
			//for each element in the bbq state array for "species" key
			for(int i = 0; i < speciesParams.length(); i++)
			{
				//JSONObject objectInArray = speciesParams.getJSONObject(i);
				String speciesInArray = speciesParams.getString(i);				
				//request.getLogger().error("JSON Object: " + speciesInArray.toString());
				//here is where you do the union			
				//put the species returned into a resource
				
				//check if the arguments in speciesParams has subclasses
				//query for some scientific name, such that:
				// superClassOfSpecies is a (kingdom, phylum, or x (non-species)) and
				//there is some superclass that is a species name
				//scientificName subClassOf superClassOfSpecies
				 //addedSpecies, hasLabel, scientificName
				//if that is the case, then add 'addedSpecies, hasLabel, scientificName'  to the union
				
				//two graphs for this:
				//http://was.tw.rpi.edu/ebird-taxonomy
				//http://was.tw.rpi.edu/ebird-data
				//namespace of scientificName: http://was.tw.rpi.edu/source/bird-data/dataset/ebird-data/vocab/enhancement/1/
				
				//here is where I can check results of subClassOf hierarchy query, and then union it
				String resultStr = queryIfTaxonomicCategory(request, speciesInArray);
				//if there are any bindings union up				
				if(resultStr != "FAILURE"){
			    request.getLogger().error("subclassOf results: " + resultStr);
			    JSONObject results = new JSONObject(resultStr);
			    JSONArray data = (JSONArray) results.get("data");
			    //data.length is  > 0 then there were positive results, so now we can ask for subclasses of selection
			    request.getLogger().error("data.length : " + data.length());

			    	if(data.length() > 0){			    		
			    		//just use the pattern species subClassOf speciesSelection
		    			final QueryResource addedSpecies = query.getResource(speciesInArray);
		    			final QueryResource subClassOf = query.getResource(RDFS_NS+"subClassOf");
						coll = union.getUnionComponent(i);
						//final NamedGraphComponent graph3 = query.getNamedGraph("http://was.tw.rpi.edu/ebird-taxonomy");
						//coll.addGraphComponent(graph3);					
						//ebird taxonomy graph
						
						//coll.addPattern(measurement, hasCommonName, commonName);
						////coll.addPattern(measurement, hasScientificName, scientificName);				
				        coll.addPattern(species, subClassOf, addedSpecies);	
				        coll.addPattern(species, hasLabel, scientificName);	
				        //ebird data graph (already handled in the first part of the query)
				        //graph3.addPattern(addedSpecies, hasLabel, scientificName);			    			
			    		/*
			    		for(int n = 0; n < data.length(); n++)
			    		{
			    			JSONObject objectInArray = data.getJSONObject(n);
			    			String speciesForQuery = objectInArray.get("species").toString();
			    			request.getLogger().error("species for query: " + speciesForQuery);    	    			
			    			final QueryResource addedSpecies = query.getResource(speciesForQuery);
							coll = union.getUnionComponent(n);
					        coll.addPattern(addedSpecies, hasLabel, scientificName);			    			
			    		}
			    		*/
			    	}
			    	else{
					    request.getLogger().error("(no results for queryIfTaxonomicCategory)");
					  final QueryResource addedSpecies = query.getResource(speciesInArray);
						coll = union.getUnionComponent(i);
				        coll.addPattern(addedSpecies, hasLabel, scientificName);		
			    	}
				}
				else{
				    request.getLogger().error("(failure to queryIfTaxonomicCategory)");
				}			      			    					
			}			
		}	
		else if (((JSONArray) request.getParam("species")).length() == 1){
		    request.getLogger().error("(got to else if where species == 1)");

			JSONArray speciesParams = (JSONArray)request.getParam("species");	
			String speciesInArray = speciesParams.getString(0);		
			String resultStr = queryIfTaxonomicCategory(request, speciesInArray);
			if(resultStr != "FAILURE"){
			    request.getLogger().error("subclassOf results: " + resultStr);
			    JSONObject results = new JSONObject(resultStr);
			    JSONArray data = (JSONArray) results.get("data");
			    	//data.length is  > 0 then there were positive results, so now we can ask for subclasses of selection
			    request.getLogger().error("data.length : " + data.length());
			    final NamedGraphComponent graph2 = query.getNamedGraph("http://was.tw.rpi.edu/ebird-taxonomy");
				final QueryResource addedSpecies = query.getResource(speciesInArray);
			    	if(data.length() > 0){			    		
			    		//just use the pattern species subClassOf speciesSelection
		    			final QueryResource subClassOf = query.getResource(RDFS_NS+"subClassOf");

					    request.getLogger().error("addedSpecies: " + addedSpecies.toString());
					    request.getLogger().error("species: " + species.toString());
					    request.getLogger().error("subclassof: " + subClassOf.toString());

					    
						////graph2.addPattern(measurement, hasScientificName, scientificName);				
				        graph2.addPattern(species, subClassOf, addedSpecies);	
				        graph2.addPattern(species, hasLabel, scientificName);				       
			    	}
			    	else{
					    request.getLogger().error("(no results for queryIfTaxonomicCategory)");
						graph2.addPattern(addedSpecies, hasLabel, scientificName);		
			    	}
				}		
		}
		else{
			final NamedGraphComponent graph2 = query.getNamedGraph("http://was.tw.rpi.edu/ebird-taxonomy");
		////	graph2.addPattern(measurement, hasScientificName, scientificName);				
			graph2.addPattern(species, hasLabel, scientificName);		
		}//for this case the species is left as a variable and is not constrained, "all bird counts" for the county
				